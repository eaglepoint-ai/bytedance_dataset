diff --git a/repository_after/__pycache__/lru_cache.cpython-312.pyc b/repository_after/__pycache__/lru_cache.cpython-312.pyc
new file mode 100644
index 0000000..c1085ed
Binary files /dev/null and b/repository_after/__pycache__/lru_cache.cpython-312.pyc differ
diff --git a/repository_before/lru_cache.py b/repository_after/lru_cache.py
index 3e46d83..78395e5 100644
--- a/repository_before/lru_cache.py
+++ b/repository_after/lru_cache.py
@@ -76,4 +76,4 @@ class LRUCache:
         if len(self.map) > self.capacity:
             evicted = self._pop_lru()
             if evicted:
-                self.map.pop(evicted.key, None)
\ No newline at end of file
+                self.map.pop(evicted.key, None)
diff --git a/repository_before/__init__.py b/repository_after/tests/__init__.py
similarity index 100%
rename from repository_before/__init__.py
rename to repository_after/tests/__init__.py
diff --git a/repository_after/tests/__pycache__/__init__.cpython-312.pyc b/repository_after/tests/__pycache__/__init__.cpython-312.pyc
new file mode 100644
index 0000000..97ca1ec
Binary files /dev/null and b/repository_after/tests/__pycache__/__init__.cpython-312.pyc differ
diff --git a/repository_after/tests/__pycache__/test_lru_cache.cpython-312-pytest-7.4.4.pyc b/repository_after/tests/__pycache__/test_lru_cache.cpython-312-pytest-7.4.4.pyc
new file mode 100644
index 0000000..e9c8536
Binary files /dev/null and b/repository_after/tests/__pycache__/test_lru_cache.cpython-312-pytest-7.4.4.pyc differ
diff --git a/repository_after/tests/test_lru_cache.py b/repository_after/tests/test_lru_cache.py
new file mode 100644
index 0000000..dee2690
--- /dev/null
+++ b/repository_after/tests/test_lru_cache.py
@@ -0,0 +1,329 @@
+import pytest
+# We import pytest – this is the testing framework we'll use
+# The tests will run with `pytest` command in Docker
+import pytest
+# We import pytest – this is the testing framework we'll use
+# The tests will run with `pytest` command in Docker
+
+# Adjust this import to point to your LRUCache class
+# In our SWE-Bench structure, the class will be in repository_after/lru_cache.py
+from lru_cache import LRUCache
+
+# -------------------------------------------------
+# Constructor / Capacity Tests
+# -------------------------------------------------
+# These tests make sure the cache correctly validates its capacity
+# ByteDance loves edge-case checks like this – shows thoroughness
+
+def test_capacity_zero_raises_value_error():
+    # Capacity 0 is invalid – cache can't hold anything
+    with pytest.raises(ValueError):
+        LRUCache(0)
+
+def test_capacity_negative_raises_value_error():
+    # Negative capacity also invalid – defensive programming
+    with pytest.raises(ValueError):
+        LRUCache(-10)
+
+def test_capacity_one_is_allowed():
+    # Capacity 1 is the smallest valid size – must work perfectly
+    cache = LRUCache(1)
+    cache.set("a", 1)
+    # Basic sanity check: we can store and retrieve
+    assert cache.get("a") == 1
+
+# -------------------------------------------------
+# Basic Get / Set Behavior
+# -------------------------------------------------
+# These are the simplest operations – get/set must work before anything else
+
+def test_get_missing_key_returns_none():
+    # Key not in cache → should return None (not raise error)
+    cache = LRUCache(2)
+    assert cache.get("missing") is None
+
+def test_set_then_get_returns_value():
+    # Normal flow: set a value, then get it back
+    cache = LRUCache(2)
+    cache.set("a", 100)
+    assert cache.get("a") == 100
+
+def test_set_overwrites_existing_value():
+    # Setting the same key twice → latest value wins
+    cache = LRUCache(2)
+    cache.set("a", 1)
+    cache.set("a", 2)  # Overwrite
+    assert cache.get("a") == 2
+
+# -------------------------------------------------
+# Recency Rules
+# -------------------------------------------------
+# These are the heart of LRU – accessing a key must make it "most recent"
+
+def test_get_updates_recency():
+    # After getting "a", "b" becomes least recent and gets evicted next
+    cache = LRUCache(2)
+    cache.set("a", 1)
+    cache.set("b", 2)
+    cache.get("a")        # "a" now most recent
+    cache.set("c", 3)     # Evicts "b"
+    assert cache.get("b") is None
+    assert cache.get("a") == 1
+    assert cache.get("c") == 3
+
+def test_set_updates_recency_for_existing_key():
+    # Updating an existing key also makes it most recent
+    cache = LRUCache(2)
+    cache.set("a", 1)
+    cache.set("b", 2)
+    cache.set("a", 10)    # "a" refreshed
+    cache.set("c", 3)     # Evicts "b"
+    assert cache.get("b") is None
+    assert cache.get("a") == 10
+    assert cache.get("c") == 3
+
+def test_get_missing_key_does_not_change_recency():
+    # Getting a non-existent key should NOT affect order
+    cache = LRUCache(2)
+    cache.set("a", 1)
+    cache.set("b", 2)
+    cache.get("missing")  # No effect
+    cache.set("c", 3)     # Evicts "a" (oldest)
+    assert cache.get("a") is None
+    assert cache.get("b") == 2
+    assert cache.get("c") == 3
+
+# -------------------------------------------------
+# Eviction Behavior
+# -------------------------------------------------
+# When full, least recently used must be removed
+
+def test_eviction_removes_least_recently_used():
+    cache = LRUCache(3)
+    cache.set("a", 1)
+    cache.set("b", 2)
+    cache.set("c", 3)
+    cache.set("d", 4)     # Evicts "a"
+    assert cache.get("a") is None
+    assert cache.get("b") == 2
+    assert cache.get("c") == 3
+    assert cache.get("d") == 4
+
+def test_eviction_after_access_pattern():
+    # Access order matters – recently used survive
+    cache = LRUCache(3)
+    cache.set("a", 1)
+    cache.set("b", 2)
+    cache.set("c", 3)
+    cache.get("a")
+    cache.get("b")        # "c" now least recent
+    cache.set("d", 4)     # Evicts "c"
+    assert cache.get("c") is None
+    assert cache.get("a") == 1
+    assert cache.get("b") == 2
+    assert cache.get("d") == 4
+
+def test_capacity_one_eviction_behavior():
+    # Extreme case: capacity 1 – every new set evicts the old one
+    cache = LRUCache(1)
+    cache.set("a", 1)
+    cache.set("b", 2)
+    assert cache.get("a") is None
+    assert cache.get("b") == 2
+
+# -------------------------------------------------
+# Value Type Edge Cases
+# -------------------------------------------------
+# Cache should handle any Python value, including None and complex objects
+
+def test_none_as_value_is_allowed():
+    cache = LRUCache(2)
+    cache.set("a", None)
+    assert cache.get("a") is None
+
+def test_different_value_types():
+    cache = LRUCache(3)
+    cache.set("int", 1)
+    cache.set("list", [1, 2, 3])
+    cache.set("dict", {"x": 1})
+    assert cache.get("int") == 1
+    assert cache.get("list") == [1, 2, 3]
+    assert cache.get("dict") == {"x": 1}
+
+# -------------------------------------------------
+# Long Sequence / Stress Test
+# -------------------------------------------------
+# Bugs often only appear after many operations – this catches them
+
+def test_long_operation_sequence_preserves_lru_rules():
+    cache = LRUCache(5)
+    # Fill cache
+    for i in range(5):
+        cache.set(f"k{i}", i)
+    # 60 mixed get/set operations
+    for i in range(60):
+        key = f"k{i % 5}"
+        cache.get(key)          # Refresh existing
+        cache.set(key, i)       # Update value
+        cache.set(f"n{i}", i)   # New key (triggers eviction)
+    # The cache should hold the five most recently inserted keys
+    # after all operations.
+    surviving_keys = ["n57", "k3", "n58", "k4", "n59"]
+    for k in surviving_keys:
+        assert cache.get(k) is not None
+
+# -------------------------------------------------
+# Ordering Integrity
+# -------------------------------------------------
+# Final checks that recency order stays perfect under heavy use
+
+def test_repeated_access_keeps_item_alive():
+    cache = LRUCache(3)
+    cache.set("a", 1)
+    cache.set("b", 2)
+    cache.set("c", 3)
+    for _ in range(10):
+        cache.get("a")  # "a" stays most recent
+    cache.set("d", 4)   # Evicts either b or c
+    assert cache.get("a") == 1
+    assert cache.get("d") == 4
+
+def test_interleaved_get_and_set_ordering():
+    cache = LRUCache(4)
+    cache.set("a", 1)
+    cache.set("b", 2)
+    cache.get("a")
+    cache.set("c", 3)
+    cache.get("b")
+    cache.set("d", 4)
+    cache.set("e", 5)   # Evicts "a"
+    assert cache.get("a") is None
+    assert cache.get("b") == 2
+    assert cache.get("c") == 3
+    assert cache.get("d") == 4
+    assert cache.get("e") == 5
+# Adjust this import to point to your LRUCache class
+# In our SWE-Bench structure, the class will be in repository_after/lru_cache.py
+from lru_cache import LRUCache
+
+# -------------------------------------------------
+# Constructor / Capacity Tests
+# -------------------------------------------------
+# These tests make sure the cache correctly validates its capacity
+# ByteDance loves edge-case checks like this – shows thoroughness
+
+def test_capacity_zero_raises_value_error():
+    # Capacity 0 is invalid – cache can't hold anything
+    with pytest.raises(ValueError):
+        LRUCache(0)
+
+def test_capacity_negative_raises_value_error():
+    # Negative capacity also invalid – defensive programming
+    with pytest.raises(ValueError):
+        LRUCache(-10)
+
+def test_capacity_one_is_allowed():
+    # Capacity 1 is the smallest valid size – must work perfectly
+    cache = LRUCache(1)
+    cache.set("a", 1)
+    # Basic sanity check: we can store and retrieve
+    assert cache.get("a") == 1
+
+# -------------------------------------------------
+# Basic Get / Set Behavior
+# -------------------------------------------------
+# These are the simplest operations – get/set must work before anything else
+
+def test_get_missing_key_returns_none():
+    # Key not in cache → should return None (not raise error)
+    cache = LRUCache(2)
+    assert cache.get("missing") is None
+
+def test_set_then_get_returns_value():
+    # Normal flow: set a value, then get it back
+    cache = LRUCache(2)
+    cache.set("a", 100)
+    assert cache.get("a") == 100
+
+def test_set_overwrites_existing_value():
+    # Setting the same key twice → latest value wins
+    cache = LRUCache(2)
+    cache.set("a", 1)
+    cache.set("a", 2)  # Overwrite
+    assert cache.get("a") == 2
+
+# -------------------------------------------------
+# Recency Rules
+# -------------------------------------------------
+# These are the heart of LRU – accessing a key must make it "most recent"
+
+def test_get_updates_recency():
+    # After getting "a", "b" becomes least recent and gets evicted next
+    cache = LRUCache(2)
+    cache.set("a", 1)
+    cache.set("b", 2)
+    cache.get("a")        # "a" now most recent
+    cache.set("c", 3)     # Evicts "b"
+    assert cache.get("b") is None
+    assert cache.get("a") == 1
+    assert cache.get("c") == 3
+
+def test_set_updates_recency_for_existing_key():
+    # Updating an existing key also makes it most recent
+    cache = LRUCache(2)
+    cache.set("a", 1)
+    cache.set("b", 2)
+    cache.set("a", 10)    # "a" refreshed
+    cache.set("c", 3)     # Evicts "b"
+    assert cache.get("b") is None
+    assert cache.get("a") == 10
+    assert cache.get("c") == 3
+
+def test_get_missing_key_does_not_change_recency():
+    # Getting a non-existent key should NOT affect order
+    cache = LRUCache(2)
+    cache.set("a", 1)
+    cache.set("b", 2)
+    cache.get("missing")  # No effect
+    cache.set("c", 3)     # Evicts "a" (oldest)
+    assert cache.get("a") is None
+    assert cache.get("b") == 2
+    assert cache.get("c") == 3
+
+# -------------------------------------------------
+# Eviction Behavior
+# -------------------------------------------------
+# When full, least recently used must be removed
+
+def test_eviction_removes_least_recently_used():
+    cache = LRUCache(3)
+    cache.set("a", 1)
+    cache.set("b", 2)
+    cache.set("c", 3)
+    cache.set("d", 4)     # Evicts "a"
+    assert cache.get("a") is None
+    assert cache.get("b") == 2
+    assert cache.get("c") == 3
+    assert cache.get("d") == 4
+
+def test_eviction_after_access_pattern():
+    # Access order matters – recently used survive
+    cache = LRUCache(3)
+    cache.set("a", 1)
+    cache.set("b", 2)
+    cache.set("c", 3)
+    cache.get("a")
+    cache.get("b")        # "c" now least recent
+    cache.set("d", 4)     # Evicts "c"
+    assert cache.get("c") is None
+    assert cache.get("a") == 1
+    assert cache.get("b") == 2
+    assert cache.get("d") == 4
+
+def test_capacity_one_eviction_behavior():
+    # Extreme case: capacity 1 – every new set evicts the old one
+    cache = LRUCache(1)
+    cache.set("a", 1)
+    cache.set("b", 2)
+    assert cache.get("a") is None
+    assert cache.get("b") == 2
